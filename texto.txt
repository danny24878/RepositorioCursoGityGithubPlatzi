

                                Git y GitHub

-----------------Crear un repositorio de Git y haz tu primer commit----------------- 

En la carpeta principal de nuestro proyecto, debemos usar el comando:
			                    
                                ‘git init’

Entonces, creará unas carpetas ocultas que guardará los cambios atómicos de nuestro proyecto. 

Con el comando :

                                'git status'

podemos, evidentemente; ver el status del proyecto. En este caso, git detectará que agramos un 
nuevo archivo, pero éste aún no ha sido agregado (commit) al repositorio, con lo cual, primero 
debemos agregarlo con el comando:

                                'Git add'

Pero aún no ha sido subido (commit) al repositorio, se encuentra en la memoria ram, a este estado de
lo conocemos como: 'cached' << o algo así>>. al volver a ver el status del archivo, estára dentro de 
los estados (has been cached).

*si queremos agregar todo el archivo, es suficiente con con: git add .*

Si queremos deshacernos de la base que va ser mandada al repositorio, tenenmos el comando:

                        'git rm --cached <file>' -> unstage (donde stage significa que ha sido agragado al cached)

Ahora que el archivo que está en estado 'cached', podemos subirlo (commit), con el comando:

                                'git commit'
Sin embargo, es no suficiene, se considera una buena práctica dejar un mensaje con cada commit, simplemente
agregando -m "<mensaje>" PEEEEEEEEERO nos falta algo muy importante que no nos dejará completar el commit
hasta que nos identifiquemos con Git agregando nuesto nombre correo etc...

Con el comando: 
                                
                                "git config"

sólo nos dirá como funciona el comando pero, con el comando: 

                                "git config --list" 

nos dará las configuraciones por defecto de nuestro git.
También con: 

                            "git config --list --show-origin 

Podremos ver dónde se encuenran las configuraciones (rutas), pero  esto es más avanzado y para hacerlo, tenemos el 
comando:                    

                            " git config --global user.name <usser> "

Así como:

                            " git config --globla user.email <email usser> "

Finalmente, daremos otros comandos que pueden ser de utilidad:

Si por algún motivo te equivocaste en el nombre o email que configuraste al principio, lo puedes modificar de la siguiente manera:
                        
                        "git config --global --replace-all user.name "<username>" "

O si lo deseas eliminar y añadir uno nuevo
                        
                        "git config --global --unset-all user.name :Elimina el nombre del usuario "

para despúes:

                   "git config --global --add user.name “Aquí va tu nombre”



------------------------- Analizar cambios en los archivos en e proyecto con Git --------------------------

El comando: 
                                    "git show" 

nos muestra los cambios que han existido sobre un archivo y es muy útil para detectar cuándo se produjeron ciertos
cambios, qué se rompió y cómo lo podemos solucionar. Pero podemos ser más detallados.

Si queremos ver la diferencia entre una versión y otra, no necesariamente todos los cambios desde la creación del
archivo, podemos usar el comando:
                                    "git diff <commit a> <commit b >"

donde "<commit a>" y "<commit b> son los ID. Es siempre recomendable utilizar los commit más viejos al principio, 
de esta manera, es más fácil e intuitivo leer lo que nos devuelve git ya que, git toma el primer commit como el más 
antíguo de ambos.

------------------------ Branch(rama) y cómo funciona un Merge en Git -----------------------------

Cuando creas tu repositorio en tu carpeta de trabajo, se crea, por defecto; una rama (Branch) principal llamada Masternica

Branch se puede ver como la linea principal de nuestro proyectos creada por los commits hechos anteriormente.

Podemos crear varios branch a traves del main (nombre que se le dá a la rama principal o master al momento de empezar a 
ramificar en la misma) y cada nuevo branch tiene sus propios commits. 

Por lo general, se puede hacer una rama, llamada " development"; basada en la ramma main y la cual tinene como propósito 
hacer cambios y modificaciónes a nuestro proyecto sin afectar al branch main <<experimentar>>

En dado caso de hallar un error en el branch main tal que, afecte al proyecto de forma considerable, podemos crear una rama 
llamada " bug fixing " o " hot fix " para hacer los arreglos necesarios para posteriormente, integrarlos a la ramma main para
que los cambios sean aplicados, utilizando el comando: 

                                            "merge"

el cual, combina los cambios del branch bug fix con el branch main

Producir una nueva rama se le conoce como " Checkout "  y a unir dos ramas como " Merge " y al hacer este último, generamos una nueva 
rama de nuestro branch main que ya tiene todas las modificaciónes del branch en cuestión

Gracias que podemos ramificar, modificar y juntar otras ramas un sin fin de veces, junto con el hecho de que podemos acudir a 
veersiones anteriores de nuestro proyecto, podemos aprovechar el registro de cambios, podemos traer versiones viejas de nuesto proyecto, 
arreglarlas y volverlas a unir para mejorarlo (entre otra infinita posibilidad de usos). 
Pero, tenemos el riesgo de cometer errores al momento de hacer un merge y este no salga como planeamos por lo que nuesta intervención 
directa será necesária. 


------------------------ Volver a versiones pasadas de nuestro repositorio utilizando reset y checkout --------------------------------

Primero, podemos ver todos los commits con sus I.D hechos enlistados con:

                                 "log" 

Tomando el I.D. de alguún commit anterir. Podemos regrear a una versión anterior. Con el comando

                                " git reset " + "< I.D. >" + "--soft"

el cual, mantiene el archivo original en staging para que podamos aplicar nuestros últimos cambios pero desde el commit anterior. Mietras que
con el argumento: 

                                 "--hard"

directamente borramos toda la información de nuestro staging permanentemente. Lo cual podemos confirmar con git log

Para poder los cambios específicos de cada archivo para cada commit con:
                            
                                 "git log --stat"

El comando:                                             

                            "git checkout + <I.D.> + <file>"

Nos permite ver el arcivo en ese momento. Hay que tener cuidado, ya que al hacer un commit, borrará el de nuestro staging y será remplazado por lo que cambie en el
commit que nos encontramos.
Para eso, basta con usar :

                            "git checkout + master + <file>"
                            
para regresar a nuesto ultimo commit. 


--------------------------------- git reset vs git rm --------------------------------------------------------

Git rm: 

Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo 
solo debemos “viajar en el tiempo” y recuperar el último commit antes de borrar el archivo en cuestión.

Recuerda que git rm no puede usarse así nomás. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última 
versión del proyecto:

                                            git rm --cached: 

Elimina los archivos de nuestro repositorio local y del área de staging, pero los mantiene en nuestro disco duro. Básicamente 
le dice a Git que deje de trackear el historial de cambios de estos archivos, por lo que pasaran a un estado untracked.

                                            git rm --force: 

Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos,
de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).

En cambio git reset nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado 
sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.
Este comando es muy peligroso y debemos emplearlo solo en caso de emergencia

¡Pero todavía falta algo!

                                            git reset HEAD:
                                            
Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos 
archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.

si usamos git reset HEAD, lo único que haremos será mover estos cambios de Staging a Unstaged. Seguiremos teniendo los últimos cambios del archivo, 
el repositorio mantendrá el archivo (no con sus últimos cambios, pero sí con los últimos en los que hicimos commit) y no habremos perdido nada.


----------------------------- Fusión de ramas con Git -------------------------------------------

